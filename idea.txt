Modelo del calabozo
Tendremos un grafo con un nodo por cada cuadradito del calabozo. Es decir, el total
de nodos será la multiplicación de los tres números en el encabezado del archivo.
Cuando un nodo está conectado a otro quiere decir que amboso no son roca y que se
puede ir de uno al otro. Un nodo aislado es una roca o un punto inaccesible.
Como la mayoría de los nodos serán rocas entonces será mejor utilizar el grafo basado
en listas para ser más eficientes.
Tendremos dos variables que indiquen el número de nodo que representa la entrada y 
otro para la salida.

Cargar el calabozo
Se extraen y multiplican los números del encabezado e inicilizamos un grafo con esta
cantidad de nodos.
Creamos un arreglo de booleanos de tamaño igual a la cantidad de nodos. False representa
que el nodo asociado es una roca y True significa que es un espacio libre. No nos preocu-
paremos por inicializar el arreglo, ya veremos por qué.
En el archivo tenemos cada piso del calabozo. Digamos que el primer piso descrito en el
archivo corresponde al primer nivel y el último en el archivo corresponde al nivel
más bajo del calabozo.

Supongamos que tenemos este archivo:
2 3 3
###
#S.
#..

E..
##.
###

Numeramos los nodos de la siguiente forma:
1 2 3
4 5 6
7 8 9

10 11 12
13 14 15
16 17 18

El arreglo quedaría: [F,F,F,F,T,T,F,T,T,T,T,T,F,F,T,F,F,F]

numNodo=0
Para cada piso en el archivo hacer
     Leer una línea
     Para cada caracter en esa línea hacer
          numNodo++
     	  Si el caracter es un #
	     arreglo[numNodo]=false
	  Sino
	     Si el caracter es S -> posicionS = numNodo
	     Si el caracter es E -> posicionE = numNodo
	     arreglo[numNodo]=true
	     Si no es el primer caracter de la linea
	     	Si arreglo[numNodo-1]!=false
		   Agregar arcos (numNodo,numNodo-1) y (numNodo-1,numNodo)
		Fin
	     Fin
	     
	     Si no es la primera línea
		Si arreglo[numNodo-numColumnas]!=false
		   Agregar arcos entre ambos nodos
		Fin
	     Fin
	     
	     Si no es el primer piso del calabozo
	     	Si arreglo[numNodo-numColumnas*NumFilas]!=false
		   Agregar arcos entre ambos nodos
		Fin
	     Fin
 	  Fin
	Fin
Fin     
	     
Nótese lo siguiente:
-Cada vez que chequeamos el arreglo estamos revisando nodos que ya visitamos
y por lo tanto inicializamos su posición en el arreglo. Es decir, cada vez
que accedemos a este arreglo sabemos que su valor es el esperado.

-Si es el primer caracter no hay nodo anterior, por lo tanto se salta esta parte
Igual para las demás condiciones.

-Estas tres comparaciones son suficientes, tomemos un nodo '1' no roca y sus nodos vecinos
 2..6. Con este algoritmo evaluaríamos los nodos 2, 3 y 6, mientras que los demás vecinos
parecen quedar sin evaluar. Sin embargo, cuando evaluemos el nodo 4, su nodo anterior es
1 así que no perdemos el posible arco {1,4}. Lo mismo sucede con los nodos 7 y 5.
Conclusión, para cada nodo solo hay que evaluar 3 nodos adyacentes a ver si no son rocas,
si evaluamos todos estaremos repitiendo comparaciones.

Piso 1 Piso 2 Piso 3
.....   ..... .....
.....   ..3.. .....
..6..   .214. ..7..
.....   ..5.. .....
.....   ..... .....

Implementación DFS
Podemos implementar una Cola basada en el tipo Lista. De hecho, podríamos usar
hasta el tipo lista directamente, pero me parece más bonito hacer un cola
propiamente dicha aunque sea simplemente una abstracción sobre el tipo Lista

Las cadenas las podemos representar como arreglos de tamaño 2 con:
posicion 0: costo
posicion 1: nodo terminal
No hay que guardar el nodo anterior porque no queremos devolver el camino sino
simplemente el tiempo. Podemos además incorporar en el algoritmo de DFS una
pequeña optimización, la cual es que si en una iteración expande hacia el
nodo E, que se detenga y devuelva el costo que obtuvo. Si por el contrario
el algoritmo deja la cola vacía entonces no consiguió camino, entonces
está atrapado.
